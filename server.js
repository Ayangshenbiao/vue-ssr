/*let cluster = require('cluster');
let clusterNum = 0;
if (cluster.isMaster) {
    let numCPUs = require('os').cpus();
    numCPUs.map(() => {
        cluster.fork()
    });
    cluster.on('listening', (worker, address) => {
        clusterNum++;
        if (clusterNum === numCPUs.length) {
            console.log('项目启动成功！')
        }
    });
    cluster.on('exit', (worker, code, signal) => {
        setTimeout(function () {
            cluster.fork()
        }, 2000)
    });
} else if (cluster.isWorker) {*/
const fs = require('fs');
const path = require('path');
const LRU = require('lru-cache');
const express = require('express');
const cookieParser = require('cookie-parser');
const favicon = require('serve-favicon');
const compression = require('compression');
const microcache = require('route-cache');
const bodyParser = require('body-parser');
const resolve = file => path.resolve(__dirname, file);
const {createBundleRenderer} = require('vue-server-renderer');
const serialize = require('serialize-javascript');
const isProd = process.env.NODE_ENV === 'production';
const useMicroCache = process.env.MICRO_CACHE !== 'false';
const serverInfo = `express/${require('express/package.json').version} ` + `vue-server-renderer/${require('vue-server-renderer/package.json').version}`;
let fileName = path.basename(__filename);
// get router config
let routerPaths = {};
let routerPathsObj = {};

fs.readdirSync('./src/router').map(file => {
  if (file === 'index-server.js' || file === 'index-client.js') {
    return false;
  }
  let router = require(`./src/router/${file}`);
  if (router) {
    let model = file.split('.js')[0];
    routerPaths[model] = router;
    for (let route in router) {
      routerPathsObj[router[route].path] = model;
    }
  }
});
const app = express();

function createRenderer(bundle, options) {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  return createBundleRenderer(bundle, Object.assign(options, {
    // for component caching
    cache: LRU({
      max: 1000,
      maxAge: 1000 * 60 * 15
    }),
    // this is only needed when vue-server-renderer is npm-linked
    basedir: resolve('./dist'),
    // recommended for performance
    runInNewContext: false
  }));
}

let renderer;
let readyPromise;
const templatePath = resolve('./src/index.template.html');
const templateErrorHtml = fs.readFileSync(resolve('./src/500.template.html'), 'utf-8');

if (isProd) {
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const template = fs.readFileSync(templatePath, 'utf-8');
  const bundle = require('./dist/vue-ssr-server-bundle.json');
  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  // tags for any async chunks used during render, avoiding waterfall requests.
  const clientManifest = require('./dist/vue-ssr-client-manifest.json');
  renderer = createRenderer(bundle, {
    template,
    clientManifest
  });
} else {
  // In development: setup the dev server with watch and hot-reload,
  // and create a new renderer on bundle / index template update.
  readyPromise = require('./build/setup-dev-server')(
      app,
      templatePath,
      (bundle, options) => {
        renderer = createRenderer(bundle, options)
      }
  );
}

const serve = (path, cache) => express.static(resolve(path), {
  maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
});
app.use(bodyParser.urlencoded({
  extended: false
}));
app.use(bodyParser.json());
app.use(cookieParser());
app.use(compression({threshold: 0}));
app.use(favicon('./public/icon.ico'));
app.use('/dist', serve('./dist', true));
app.use('/public', serve('./public', true));
app.use('/manifest.json', serve('./manifest.json', true));
app.use('/service-worker.js', serve('./dist/service-worker.js'));

// since this app has no user-specific content, every page is micro-cacheable.
// if your app involves user-specific content, you need to implement custom
// logic to determine whether a request is cacheable based on its url and
// headers.
// 1-second microcache.
// https://www.nginx.com/blog/benefits-of-microcaching-nginx/
app.use(microcache.cacheSeconds(1, req => useMicroCache && req.originalUrl));
const setConfigCookie = {httpOnly: true, path: '/'};
let {logErr, logInfo} = require('./log4');

function render(req, res) {
  let reqTime = new Date();
  logInfo(fileName, 'PAGE_IN', req.url, null, req.body, req.cookies);
  res.setHeader('Content-Type', 'text/html');
  res.setHeader('Server', serverInfo);
  const handleError = err => {
    if (err.url) {
      logInfo(fileName, 'PAGE_SEND', err.url, reqTime, req.body, `redirect err url : ${err.message}`);
      res.redirect(err.url);
    } else {
      let message = '';
      if (typeof err === 'object') {
        if (err.message) {
          message = err.message;
        } else {
          message = JSON.stringify(err);
        }
      } else if (typeof err === 'string') {
        message = err;
      }
      let errorHtml = templateErrorHtml.replace(/<content[^]*>[^>]*<\/content>/gi, `<div id="errcontent" style="text-align:center"><h1>500 | Internal Server Error</h1>${message}</div>`).replace('{{title}}', '500').replace('{{keywords}}', '500').replace('{{description}}', '500');
      logErr(fileName, 'PAGE_SEND', '', reqTime, req.body, errorHtml);
      res.status(500).send(errorHtml);
    }
  };
  const context = {
    title: 'fund', // default title
    url: req.url,
    cookie: req.cookies,
    routerPaths: routerPaths,
    routerPathsObj: routerPathsObj,
    state: {
      userInfo: {
        head: {}
      }
    }
  };
  // process.__COOKIE__ = req.cookie
  // const indexHTML = {
  //   head: '',
  //   tail: ''
  // }
  // const renderStream = renderer.renderToStream(context)
  // // 当块第一次被渲染时
  // renderStream.once('data', (html) => {
  //   res.write(indexHTML.head)
  // })
  // // 每当新的块被渲染
  // renderStream.on('data', chunk => {
  //   console.log('chunk',chunk)
  //   // 将块写入响应
  //   res.write(chunk)
  // })
  // renderStream.on('end', () => {
  //   // 当vuex初始状态存在
  //   if (context.initialState) {
  //     // 将vuex初始状态以script的方式写入到页面中
  //     res.write(
  //       `<script>window.__INITIAL_STATE__=${serialize(context.initialState, {isJSON: true})}</script>`
  //     )
  //   }
  //
  //   // 将结尾的HTML写入响应
  //   res.end(indexHTML.tail)
  // })
  //
  // // 当渲染时发生错误
  // renderStream.on('error', err => {
  //   if (err && err.code === '404') {
  //     res.status(404).end('404 | Page Not Found')
  //     return
  //   }
  //   res.status(500).end('Internal Error 500')
  // })
  renderer.renderToString(context, (err, html) => {
    if (err) {
      return handleError(err)
    }
    // console.log('context',serialize(context.state.userInfo, {isJSON: true}))
    // let head = context.state.userInfo.head
    // if (head.token && head.tokenKey) {
    //   res.cookie('token', head.token || '', setConfigCookie)
    //   res.cookie('tokenkey', head.tokenKey || '', setConfigCookie)
    // }
    logInfo(fileName, 'PAGE_SEND', req.url, reqTime, req.cookie, context.state);
    res.send(html)
    // if (!isProd) {
    //   console.log(`whole request: ${Date.now() - s}ms`)
    // }
  });
}

app.get('*', isProd ? render : (req, res) => {
  readyPromise.then(() => {
    render(req, res)
  })
});

let {getConfigServer} = require('./src/config/config-server');
let configServer = getConfigServer(process.env.NODE_ENV);

let {post} = require('./src/api/create-api-server');

function templateFun(str, data) {
  let computed = str.replace(/\{\{(\w+)\}\}/g, function (match, key) {
    return data[key];
  });
  return computed;
}

function mkdir(path) {
  let pathList = path.split('/');
  let currPath = "/";

  pathList.forEach((item, index) => {
    if (item.length > 0) {
      currPath += item + "/";
      if (!fs.existsSync(currPath)) {
        //创建文件夹
        fs.mkdirSync(currPath);
      }
    }
  });

  return true;
}

function mySend(req, res, {token}, results, reqTime) {
  // set cookie
  if (token) {
    delete results.data.token;
    res.cookie('token', token, setConfigCookie);
  }

  res.status(200);
  res.send(results);
}

app.post('*', (req, res) => {
  if (req.url.startsWith(configServer.uploadFile.startUrl)) {
    const formidable = require("formidable"); //载入 formidable
    let form = new formidable.IncomingForm();

    form.keepExtensions = configServer.uploadFile.keepExtensions; //保持原来的文件的扩展名
    form.uploadDir = configServer.uploadFile.tmpFilePath; //设置上传文件存放的文件夹
    form.maxFileSize = configServer.uploadFile.maxFileSize * 1024 * 1024; //上传文件的大小
    let filePath = configServer.uploadFile.filePath;

    form.parse(req, function (err, fields, files) {
      if (err) {
        console.log(err);
        return res.json({
          "code": 500,
          "message": "文件解析出错"
        });
      }

      let file = files.file;
      let fileType = fields.fileType;
      let staticPath = templateFun(configServer.uploadFile[fileType].staticPath, fields);
      let recvFileName = templateFun(configServer.uploadFile[fileType].fileName, fields);
      let sendUrl = configServer.uploadFile[fileType].url;
      let result = mkdir(filePath + staticPath);
      if (!result) {
        return res.json({
          "code": 500,
          "message": "目录创建失败"
        });
      }
      //拿到扩展名
      let extname = path.extname(file.name);
      fs.rename(file.path, filePath + staticPath + recvFileName + extname, function (err) {
        if (err) {
          console.error("文件重命名错误");
          return res.json({
            "code": 500,
            "message": "文件重命名错误"
          });
        }
        console.log("文件重命名成功");
      });
      //调用后台接口
      let options = fields || {};
      options.vcPath = filePath + staticPath;
      options.vcStaticPath = staticPath + recvFileName + extname;
      options.fileId = recvFileName + extname;
      req.url = sendUrl;
      req.body = options;

      logInfo(fileName, 'SEND_START', req.url, null, req.body, req.cookies);
      let reqTime = new Date();
      let url = req.url.split('?')[0];
      post(req.url, req.body, req.cookies).then((data) => {
        // user out
        if (url === '/logout') {
          res.clearCookie('token');
          res.clearCookie('tokenKey');
        }
        mySend(req, res, {token: data.data && data.data.token}, data, reqTime);
      }).catch(error => {
        res.send(error);
      });
    });
  } else {
    logInfo(fileName, 'SEND_START', req.url, null, req.body, req.cookies);
    let reqTime = new Date();
    let url = req.url.split('?')[0];
    post(req.url, req.body, req.cookies).then((data) => {
      // user out
      if (url === '/logout') {
        res.clearCookie('token');
        res.clearCookie('tokenKey');
      }
      mySend(req, res, {token: data.data && data.data.token}, data, reqTime);
    }).catch(error => {
      res.send(error);
    });
  }

});

// require('./src/api/config-api/config-api-server')(app)
const port = process.env.PORT || 8080;
app.listen(port, () => {
  logInfo(fileName, `server started at localhost:${port}`);
});
//}
